# Что же такое «hoisting»?
Если вас удивлял тот факт, что вы можете вызывать функции до их декларации(объявления), то эта статья для вас.

**Hoisting** - поднятие, всплытие; (глагол. hoist) поднимать, выкидывать. 
Попробуем для начала разобраться что такое hoisting из практических примеров:

```javascript
console.log(hoistingVar);
// -> undefined
var hoistingVar = "I'm not here";

```
Как видно из примера - переменная hoistingVar доступна ещё до того как задекларирована. Все в порядке, ведь в ином случае обращение 
к несуществующей переменной в JS привело бы к ReferenceError: variable is not defined; 
Вот что происходит на самом деле:

```javascript
//Javascript переместил декларацию переменной в самый верх своей области видимости.
var hoistingVar;
console.log(hoistingVar)
// -> undefined
hoistingVar = "I'm not here";
```
Это нехило так сбивает столку, такого не должно быть!
Более того, тоже самое происходит и внутри функциональной области видимости: 

```javascript
function test(){
  return test;
  var test = "I'm not here";
}

console.log(test())
// -> undefined
```

## И С декларацией ФУНКЦИИ ТОЖЕ!

Давайте переместим вызов console.log(test()) в самое начало, где функции test(), казалось бы, ещё даже не существует.

```javascript
console.log(test())

function test(){
  var test = "I should not be here";
  return test;
}

// -> "I should not be here"
```

Иии...всё работает. На самом деле JavaScript переместил декларацию функции в самый верх области видимости(абсолютно также как и декларацию переменной в предыдущем примере),
 что как бы позволяет вызывать функцию ещё до её декларации. 


Но погодите: 
```javascript
console.log(test)
// -> undefined
var test = function test(){
   var test = "I'm not here";
   return test;
}
```
Почему undefined? Ведь всё правильно - вызываем функцию до её декларации!
Дело в том, что только непосредственно декларация (var test) перемещается вверх, а не инициализация, здесь просто объявляется переменная.
??это точно тот вывод, который можно сделать из вышеизложенных примеров???,
Таким образом, HOISTING - это механизм, при котором декларации переменных и функций поднимаются на самый верх своей области видимости, ещё до выполнения кода.


## Теперь подобнее:

Первый проход? лексичский анализ, AST дерево, области видимости? Для чего вообще нужен хойстинг, его суть тут?
Есть N стульей. Declaration, function declaration blablabla и blablabla HOISTING blabla
Запомните и держите в уме одну важную вещь, JavaScript непреклонно сначала объявляет, а затем инициализирует наши переменные.

## Порядок по приоритетам


## Без декларации:
Тем не мене, с другой стороны, не объявленные переменные не существуют до тех пор пока код назначающий их не будет выполнен. Следовательно, назначение значения для не объявленной переменной, тут же создаёт её как глобальную переменную, когда назначение будет выполнено. Это означает то, что все не объявленные переменные это глобальные переменные.
+ код






## es5 strict mode и ES6: let и const?!

ШОК!
важно заметить, что JavaScript «поднимает» переменные let и const. Разница тут в том, как он инициализирует их. Переменные объявленные с let и const остаются неинициализированными 
в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.

Попробуем проделать с let и const тоже самое:
```javascript
function test(){
    return confusing;
    let confusing = "Finally!";
}

console.log(test())
//-> ReferenceError: can't access lexical declaration `confusing' before         initialization
```
Значительно приятнее, да? Аналогично с const;











![hoisting](4jop4FB.gif)
**Let** и **const**, появившиеся с версии ES6
 
[Оригинал](https://dev.to/genta/what-the-hoisting-5f824jop4FB.gif)
