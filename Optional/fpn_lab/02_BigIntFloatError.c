#include <stdio.h>
#include "print_bits.h"

void bigIntsInFloatsTest()
{
	float a = (float)123456789;
	float b = (float)123456788;
	float f = a - b;
	printf("a - b = %.0f\n", f);
	print_float(f);
	printf("a = %0.f = \n", a);
	print_float(a);
	printf("b = %0.f = \n", b);
	print_float(b);

}

int main(void)
{
	/*
	 *	очевидно нельзя представить число, превыщающее mantissa * 2^(maxExp - padding);
	 *	Диапозон целых чисел, точно представимых в формате числа с плавающих запятой
	 *	равен [-2^(mantissaLen + 1); 2^(mantissaLen + 1)], конечно существуют еще точно
	 *	представидмые целые числа(например для float 2^56 + 2^33),
	 *	но интервал между ними расширяется с увеличением числа
	 *	2^24, 2^24 + 2, 2^24 + 4, 2^24 + 6, 2^24 + 8 ...
	 *	2^25, 2^25 + 4, 2^25 + 8, 2^25 + 12, 2^24 + 16 ...
	 *	2^26, 2^26 + 8, 2^26 + 16, 2^26 + 24, 2^24 + 32 ...
	 *	....
	 *	..
	 *	2^127, 2^127 + 2^114, 2^127 + 2^115, 2^127 + 2^115 + 2^114 ...
	 *	Вплоть до (1 - 2^24) * 2^128
	 *	С того момента, как exp >= 23 У числа не может быть дробной части
	*/
	float z = -72057602627862528.0f;
	printf("%-40f\n", z);

	float n = 8388608;
	printf("%.30f\n", n);

	bigIntsInFloatsTest();

	/* Невозможность представление в двоичной форме:
	 * В формате IEEE 754-2008 можно представить только рациональные числа по основанию 2
	 * Количество разрядов ограниченно, поэтому не всегда удается точно перевести из
	 * 10с.c в двоичную, обратное возможно всегда
	 * Например 1/10 представимо периодической двоичной дробью, в 23 бита мантиссы
	 * float никак не уместится
	 * В результате арифметической операции ошибка можно возникнуть как в следствие
	 * невозможности представления операндов, так и невозможности точного представления результата
	*/

	/*
	 * Нехватка количества бит для малых и минимальный предел:
	 * Понятно, что чем больше бит отведено на целую часть, тем меньший диапозон с большим интервалом
	 * можно представить в дробной;
	 * При наличии целой части наибольший диапозон дробной части = [0..0.99999988079071044921875]
	 * c наименьшим интервалом 2^-23;
	 * Далее, при представлении чисел [0;1) имеем:
	 * exp = -1, диапозон [1/2..0.999999940395355224609375], интервал 2^-24;
	 * exp = -2, диапозон [1/4..0.4999999701976776123046875f], интервал 2^-25;
	 * ....
	 * exp = -126(минимальное положительное число, представимое в нормализованном виде),
	 * диапозон [2^-126; ~2^-125], интервал 2^-149;
	 * любые далее меньше переходят в денормализованный вид
	 * exp = -126, диапозон [2^-149; 2^-126(1 - 2^-23)], интервал ==
	 * минимальному положительному, представимому в денормализованном виде 2^(-149);
	 *
	 * 1+e > 1 => машинный эпсилон = 2^-23
	 *
	 * Числа, меньшие 2^(-24) представить невозможно, только 0;
	 *
	 * */

	printf("%.100f\n", 1/713623846352979940529142984724747568191373312.0); // 2^-149
	print_float(0.0000000000000000000000000000000000000000000014012984643248170709237295832899161312802619418765157718);
	float g = 0.25/713623846352979940529142984724747568191373312.0;
	print_float(g/2.0f); //меньше уже нельзя - 0
	printf("\n");
	print_float(4.0f * 85070591730234615865843651857942052864.0f); // выход за пределы  max float дает +infinity
	print_float(4.0f * -85070591730234615865843651857942052864.0f); // выход за пределы min int дает -infinity
	return (0);
}
